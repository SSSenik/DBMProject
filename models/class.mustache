const jsf = require('json-schema-faker');
const faker = require('faker');

const database = require(__basedir + '{{{sqlitePath}}}')(__basedir + '/database/{{dbName}}')

jsf.extend('faker', () => faker);

const schema{{classTitle}} = require('../schemas/Schema-{{classTitle}}.json');

class {{classTitle}} {
    constructor({{constructorArguments}}) {
        {{#classConstructor}} 
        this.{{name}} = {{name}};
        {{/classConstructor}}

        Object.defineProperty(this, 'id', { enumerable: false, writable: true } );
        {{#classEnumerables}} 
        Object.defineProperty(this, '{{name}}', { enumerable: false });
        {{/classEnumerables}}
        {{#references}} 
        Object.defineProperty(this, '{{name}}', { enumerable: false, writable: true });
        {{/references}}
    }

    static create() {
        return Object.assign(new {{classTitle}}(), jsf.generate(schema{{classTitle}}));
    }

    static all(callback) {
        database.where("SELECT * FROM {{classTitle}}", [], {{classTitle}}, callback)
    }

    static get(id, callback) {
        database.get("SELECT * FROM {{classTitle}} WHERE id = ?", [id], {{classTitle}}, callback)
    }

    static delete(id, callback) {
        database.run("DELETE FROM {{classTitle}} WHERE id = ?", [id], callback)
    }

    static top(property, order, limit, callback) {
        database.where(
            `SELECT * FROM {{classTitle}} ORDER BY ${property} ${order} LIMIT ${limit}`,
            [],
            {{classTitle}},
            callback
        );
    }

    static getLastInserted(callback) {
        this.top('id', 'DESC', 1, callback);
    }
    
    static many(model, id, callback) {
        let tablename = ['{{classTitle}}', model].sort().join('_');
        database.where(
            `SELECT {{classTitle}}.*
        FROM {{classTitle}}
        INNER JOIN ${tablename} ON ${tablename}.${('{{classTitle}}').toLowerCase()}_id = {{classTitle}}.id
        WHERE ${tablename}.${model.toLowerCase()}_id = ?`,
            [id],
            {{classTitle}},
            callback
        );
    }
    
    static manyDelete(model, id, callback) {
        let tablename = ['{{classTitle}}', model].sort().join('_');
        database.run(
            `DELETE FROM ${tablename}
        WHERE ${tablename}.${'{{classTitle}}'.toLowerCase()}_id = ?`,
            [id],
            callback
        );
    }

    static manyInsert(model, id, values) {
        let tablename = ['{{classTitle}}', model].sort().join('_');
        for (const refid of values) {
            database.run(
                `INSERT INTO ${tablename} (${'{{classTitle}}'.toLowerCase()}_id, ${model.toLowerCase()}_id) VALUES (?, ?)`,
                [id, refid]
            );
        }
    }

    static manySave(model, id, values) {
        this.manyDelete(model, id, () => {
            this.manyInsert(model, id, values);
        });
    }

    save(callback) {
        if (this.id) {
            database.run(`UPDATE {{classTitle}} SET {{{updateColumns}}} WHERE id = ?`, 
            [{{thisColumns}}, this.id], callback);
        } else{
            database.run(`INSERT INTO {{classTitle}} ({{constructorArguments}}{{#hasRefs}},{{/hasRefs}}{{selColsRefs}}) VALUES ({{interrogationSigns}})`, 
            [{{thisColumns}}], callback);
        }
    }



}


module.exports = {{classTitle}}